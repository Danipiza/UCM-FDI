¿Cuál de los siguientes estados de un proceso indica que el proceso está bloqueado normalmente por E/S? \
a) TASK_RUNNING
b) TASK_INTERRUPTIBLE
c) TASK_UNINTERRUPTIBLE
c
¿Qué significa el identificador PPID en la gestión de procesos?
a) Identificador del proceso padre
c) Identificador de la sesión
b) Identificador del grupo de procesos
a
¿Cuál de las siguientes políticas de planificación permite que las tareas con igual prioridad se ejecuten por turnos?
a) SCHED_OTHER
b) SCHED_FIFO
c) SCHED_RR
c
¿Qué comando se utiliza para mostrar la lista de procesos y sus atributos, incluyendo el estado?
a) ps
b) top
c) htop
a
¿Cuál es el significado del valor de retorno 0 de la llamada fork() en un proceso?
a) Error al crear el proceso hijo
b) El proceso padre continúa su ejecución
c) El proceso hijo continúa su ejecución
c 
¿Qué llamada al sistema se utiliza para crear un proceso hijo en Linux?
a) execve
b) fork
c) waitpid
b 
¿Cuál de las siguientes señales no se puede capturar, bloquear o ignorar?
a) SIGINT
b) SIGSTOP
c) SIGTERM
b 
¿Qué estructura de datos contiene información sobre el encabezado de un programa en formato ELF?
a) Elf32_Phdr
b) Elf32_Ehdr
c) Elf32_Shdr
b 
¿Cuál de las siguientes funciones se utiliza para ejecutar un nuevo programa reemplazando el proceso actual?
a) execve
b) setpriority
c) getpid
a 
¿Qué comando se utiliza para cambiar la prioridad de un proceso en ejecución?
a) chrt
b) renice
c) nice
b 
¿Qué función se utiliza para obtener el identificador de proceso del proceso actual?
a) getppid
b) getpid
c) getpgid
b 
¿Cuál de las siguientes políticas de planificación se considera estándar y usa el valor de nice?
a) SCHED_FIFO
b) SCHED_RR
c) SCHED_OTHER
c
¿Qué significa el estado TASK_RUNNING en un proceso?
a) Bloqueado por E/S
b) Esperando a que un evento se complete
c) En ejecución o preparado para ejecutarse
c
¿Cuál de las siguientes llamadas al sistema establece un nuevo directorio de trabajo para un proceso?
a) setcwd
b) chdir
c) getcwd
b
¿Qué llamada al sistema se utiliza para crear una nueva sesión y un nuevo grupo de procesos?
a) setsid
b) fork
c) execve
a
¿Cuál de los siguientes valores de nice representa la mayor prioridad de CPU? \
a) 19
b) 0
c) -20
c
¿Cuál es la función utilizada para cambiar la política de planificación de un proceso?
a) sched_setscheduler
b) setpriority
c) sched_setparam
a
¿Qué comando permite cambiar la prioridad de planificación en tiempo real de un proceso? \
a) chrt
b) renice
c) nice
a 
¿Qué estructura contiene el contexto de un proceso en ejecución?
a) vm_area_struct
b) task_struct
c) mm_struct
b 
¿Qué comando de shell se utiliza para imprimir el directorio de trabajo actual?
a) cd
b) ls
c) pwd
c
¿Qué función permite a un proceso obtener la variable de entorno de otro proceso?
a) getenv
b) setenv
c) unsetenv
a
¿Cuál de los siguientes estados de proceso significa que el proceso está esperando a que se complete un evento?
a) TASK_RUNNING
b) TASK_INTERRUPTIBLE
c) TASK_UNINTERRUPTIBLE
b 
¿Qué valor de retorno de la llamada fork() indica que el proceso padre está en ejecución?
a) 0
b) -1
c) >0
c
¿Qué función se utiliza para esperar a que un proceso hijo termine su ejecución?
a) execve
b) waitpid
c) fork
b 
¿Cuál es el límite máximo de prioridad para la política SCHED_FIFO?
a) 0
b) 50
c) 99
c 
¿Qué comando se usa para ejecutar un comando de shell desde un programa en C?
a) system
b) execve
c) fork
a 
¿Cuál de los siguientes no es un tipo de señal en el sistema?
a) SIGHUP
b) SIGKILL
c) SIGSET
c 
¿Cuál de las siguientes señales se puede generar con Ctrl+C?
a) SIGINT
b) SIGTERM
c) SIGKILL
a
¿Cuál de las siguientes funciones se utiliza para cambiar el valor de nice de un proceso?
a) sched_getscheduler
b) setpriority
c) sched_setscheduler
b 
¿Cuál es el comando utilizado para obtener el uso de recursos de un proceso?
a) top
b) ps
c) getrusage
c 
¿Qué estructura se utiliza para almacenar el límite de recursos de un proceso?
a) task_struct
b) rlimit
c) sched_param
b 
¿Cuál de los siguientes comandos se utiliza para acceder a la funcionalidad de establecer límites de recursos?
a) getrlimit
b) ulimit
c) setrlimit
b 
¿Qué llamada al sistema se utiliza para obtener el valor de nice de un proceso?
a) getpriority
b) setpriority
c) getrlimit
a 
¿Qué estructura contiene el encabezado de un segmento de programa en formato ELF? \
a) Elf32_Ehdr
b) Elf32_Phdr
c) Elf32_Shdr
b 
¿Cuál de los siguientes comandos permite crear una nueva sesión en el sistema? \
a) fork
b) execve
c) setsid
c 
¿Qué comando muestra el árbol de procesos? (NO ESTA EN LOS APUNTES)
a) pstree
b) top
c) ps
a
¿Cuál de los siguientes estados de proceso no es un estado válido?
a) TASK_RUNNING
b) TASK_STOPPED
c) TASK_ZOMBIE
b 
¿Qué función en C se utiliza para enviar una señal a un proceso?
a) kill
b) signal
c) raise
a 
¿Cuál de las siguientes señales es utilizada para finalizar un proceso de manera amistosa?
a) SIGKILL
b) SIGTRAP
c) SIGTERM
c 
¿Qué comando muestra el uso de memoria por procesos?
a) top
b) free
c) vmstat
a
¿Cuál de los siguientes es un método para sincronizar procesos?
a) Pipes
b) Signals
c) Semaphores
c 
¿Qué comando permite ver la jerarquía de procesos de manera interactiva? (NO ESTA EN LOS APUNTES)
a) htop
b) ps
c) pstree
a
¿Qué comando se utiliza para enviar una señal a un proceso desde la línea de comandos?
a) send
b) sigsend
c) kill
c 
¿Qué función se usa para crear un hilo en un programa en C? (NO ESTA EN LOS APUNTES)
a) pthread_create
b) fork
c) execve
a 
¿Cuál de los siguientes es un valor de retorno posible de la función waitpid() que indica que no hay más hijos por esperar? \
a) 0
b) -1
c) PID del hijo terminado
b 
¿Qué comando se usa para limitar el uso de recursos de un comando específico?
a) ulimit
b) top
c) renice
a 
¿Cuál es la función utilizada para obtener el tiempo de CPU utilizado por un proceso?
a) getrusage
b) gettimeofday
c) time
a 
¿Qué llamada al sistema se utiliza para cambiar el grupo de procesos de un proceso? \
a) setpgid
b) setgid
c) setuid
a
¿Cuál de las siguientes funciones permite la ejecución de un nuevo programa en el contexto del proceso actual?
a) fork
b) execve
c) wait
b 
¿Qué estado tiene un proceso que ha terminado su ejecución pero aún no ha sido recolectado por su proceso padre?
a) TASK_RUNNING
b) TASK_ZOMBIE
c) TASK_STOPPED
b 
¿Qué comando en Linux muestra información sobre los identificadores de usuario y grupo? (NO ESTA EN LOS APUNTES) \
a) id
b) whoami
c) who
a 
¿Cuál es el propósito de la llamada al sistema nice?
a) Cambiar el valor de prioridad de un proceso
b) Finalizar un proceso
c) Crear un nuevo proceso
a
¿Qué comando se utiliza para ver las estadísticas del sistema, como el uso de CPU y memoria? (NO ESTA EN LOS APUNTES) \
a) top
b) vmstat
c) free
b 
¿Qué señal no puede ser ignorada ni manejada por un proceso?
a) SIGTERM
b) SIGINT
c) SIGKILL
c 
¿Cuál de los siguientes comandos puede mostrar el estado de la memoria swap? (NO ESTA EN LOS APUNTES)
a) free
b) ps
c) top
a 
¿Qué significa el comando nohup? (NO ESTA EN LOS APUNTES)
a) Ejecutar un comando sin esperar a que termine
b) Ejecutar un comando y desconectar del terminal
c) Ejecutar un comando ignorando la señal HUP
c 
¿Qué comando se usa para mostrar el identificador de proceso (PID) y el estado de los procesos?
a) ps
b) pidstat
c) pgrep
a  
¿Cuál es la función que suspende la ejecución de un proceso hasta que reciba una señal?
a) pause
b) kill
c) wait
a 
¿Qué significa el valor de retorno -1 de la función fork()?
a) El proceso padre está en ejecución
b) Error al crear el proceso hijo
c) El proceso hijo está en ejecución
b
¿Cuál es la función que un proceso puede utilizar para enviar una señal a otro proceso?
a) send
b) raise
c) kill
c
¿Qué función se utiliza para cambiar los límites de recursos de un proceso?
a) setrlimit
b) getrlimit
c) getrusage
a
¿Cuál de los siguientes estados indica que un proceso está esperando a que ocurra un evento específico?
a) TASK_RUNNING
b) TASK_INTERRUPTIBLE
c) TASK_UNINTERRUPTIBLE
b
¿Qué comando permite buscar procesos por nombre o por otros criterios?
a) ps
b) pgrep
c) top
b
¿Cuál de las siguientes llamadas al sistema se utiliza para terminar un proceso inmediatamente?
a) exit
b) abort
c) _exit
b 
¿Cuál de las siguientes señales indica la finalización de un proceso?
a) SIGKILL
b) SIGSTOP
c) SIGCHLD
c
¿Qué comando muestra el identificador del proceso actual?
a) pidof
b) getpid
c) ps
b 
¿Cuál de las siguientes llamadas al sistema se utiliza para crear un nuevo hilo en un programa?
a) fork
b) pthread_create
c) execve
b
¿Qué significa la política de planificación SCHED_FIFO?
a) Planificación round-robin
b) Planificación en tiempo real FIFO
c) Planificación estándar
b
¿Cuál es el propósito de la llamada al sistema wait()?
a) Esperar la finalización de cualquier hijo
b) Crear un nuevo proceso
c) Ejecutar un nuevo programa
a 
¿Qué comando se usa para cambiar el valor de prioridad de un proceso?
a) nice
b) renice
c) priority
b 
¿Qué función se utiliza para establecer el valor de nice de un proceso?
a) setpriority
b) getpriority
c) nice
a 
¿Qué llamada al sistema cambia el identificador de usuario real y efectivo de un proceso?
a) setuid
b) setgid
c) setpgid
a 
¿Cuál es la función que devuelve el tiempo de CPU utilizado por el proceso actual y sus hijos?
a) getrusage
b) gettimeofday
c) clock
a
¿Qué comando muestra la utilización de CPU de los procesos en ejecución?
a) top
b) ps
c) uptime
a 
¿Qué comando se utiliza para listar los procesos con información detallada, incluyendo su estado?
a) ps -ef
b) top
c) htop
a
¿Qué función se utiliza para finalizar la ejecución de un hilo en un programa?
a) pthread_exit
b) thread_cancel
c) pthread_kill
a 
¿Cuál de las siguientes señales es enviada por el kernel cuando un proceso intenta escribir en un canal de comunicación roto?
a) SIGPIPE
b) SIGTERM
c) SIGKILL
a 
¿Qué estado tiene un proceso que ha sido suspendido por una señal de control?
a) TASK_RUNNING
b) TASK_STOPPED
c) TASK_INTERRUPTIBLE
b 
¿Cuál es el propósito de la llamada al sistema getpriority()?
a) Obtener la prioridad de un proceso
b) Establecer la prioridad de un proceso
c) Obtener el tiempo de CPU utilizado por un proceso
a 
¿Qué comando en Linux se utiliza para mostrar las conexiones de red y las estadísticas de los sockets?
a) netstat
b) ifconfig
c) ipconfig
a 
¿Cuál de los siguientes estados indica que un proceso ha terminado pero aún no ha sido limpiado por su padre?
a) TASK_ZOMBIE
b) TASK_RUNNING
c) TASK_UNINTERRUPTIBLE
a 
¿Qué llamada al sistema se utiliza para enviar una señal a un grupo de procesos?
a) killpg
b) raise
c) kill
a 
¿Qué función se utiliza para suspender la ejecución de un hilo durante un tiempo específico? (NO ESTA EN LOS APUNTES)
a) usleep
b) sleep_thread
c) nanosleep
c 
¿Cuál de las siguientes opciones describe mejor el estado TASK_RUNNING?
a) El proceso está esperando por E/S
b) El proceso está en ejecución o listo para ejecutarse
c) El proceso está suspendido
b 
¿Cuál de los siguientes comandos se usa para terminar un proceso dado su PID?
a) kill -9
b) stop
c) terminate
a 
¿Qué estructura de datos en el kernel contiene la información de los procesos en ejecución? (NO ESTA EN LOS APUNTES)
a) task_struct
b) proc_struct
c) process_info
a 
¿Qué función permite al proceso actual esperar la finalización de un proceso hijo específico?
a) waitpid
b) fork
c) execve
a 
¿Cuál de las siguientes políticas de planificación es adecuada para sistemas de tiempo real estricto? \
a) SCHED_FIFO
b) SCHED_RR
c) SCHED_OTHER
a
¿Qué comando en Linux permite visualizar y establecer límites en los recursos que puede usar un proceso? \
a) ulimit
b) limit
c) quota
a
¿Qué función en C se utiliza para manipular señales, como bloquear o desbloquear señales específicas?
a) sigaction
b) signal
c) sigprocmask
c 
¿Qué función permite al proceso padre obtener el estado de salida de un proceso hijo? \
a) waitpid
b) exit
c) fork
a
¿Cuál de las siguientes señales se utiliza típicamente para pedir a un proceso que termine de manera segura y ordenada?
a) SIGKILL
b) SIGTERM
c) SIGSTOP
b
















¿Cuál es la función de FD_SET en la multiplexación de E/S síncrona?
a) Eliminar un descriptor de un conjunto.
b) Comprobar si un descriptor está en un conjunto.
c) Añadir un descriptor a un conjunto.
c
¿Qué indica errno=EAGAIN en una operación de E/S no bloqueante?
a) La llamada se ha completado con éxito.
b) La llamada ha fallado porque ningún descriptor está listo.
c) La llamada ha fallado debido a un error de permisos.
b
¿Cuál es el propósito de la función mkfifo?
a) Crear un archivo regular.
b) Crear una tubería con nombre.
c) Crear un dispositivo de caracteres.
b
¿Qué hace la opción O_NONBLOCK al abrir una tubería?
a) Bloquear la apertura hasta que el otro extremo esté abierto.
b) Permitir la apertura sin bloquear, incluso si la tubería no está abierta para escritura.
c) Eliminar un descriptor de un conjunto.
b
¿Qué señal genera el temporizador ITIMER_REAL cuando expira?
a) SIGVTALRM.
b) SIGALRM.
c) SIGPROF.
b
¿Qué función se usa para fijar una alarma en segundos?
a) alarm.
b) setitimer.
c) getitimer.
a
¿Cuál es el tipo de archivo creado con S_IFIFO?
a) Dispositivo de bloques.
b) Fichero regular.
c) Tubería con nombre.
c
¿Qué función se utiliza para crear una tubería sin nombre?
a) mkfifo.
b) pipe.
c) mknod.
b
¿Cuál es el comportamiento de write en una tubería sin nombre si la tubería está llena?
a) La llamada falla con errno=EAGAIN.
b) La llamada se bloquea hasta que se lean suficientes datos.
c) La llamada devuelve inmediatamente sin escribir datos.
b
¿Qué hace la función sigemptyset?
a) Inicializa un conjunto sin señales.
b) Añade una señal a un conjunto.
c) Elimina una señal de un conjunto.
a
¿Cuál es el valor de retorno de la función pause?
a) El número de segundos restantes.
b) -1 y establece errno a EINTR.
c) 0 si no hay ninguna señal pendiente.
b
¿Qué señal se utiliza para reanudar un proceso parado?
a) SIGSTOP.
b) SIGCONT.
c) SIGTSTP.
b
¿Cuál es el propósito de la máscara de señales en un proceso?
a) Definir el conjunto de señales que un proceso puede recibir.
b) Establecer qué señales están bloqueadas.
c) Indicar qué señales deben ser ignoradas.
b
¿Qué hace la función sigprocmask?
a) Captura una señal con un manejador.
b) Modifica la máscara de señales.
c) Envía una señal a un proceso.
b
¿Cuál es la función de sigaction?
a) Capturar una señal con un manejador.
b) Bloquear una señal.
c) Ignorar una señal.
a
¿Qué tipo de señales se agrupan en conjuntos POSIX?
a) Señales dependientes del sistema.
b) Señales de usuario.
c) Todas las señales disponibles en el sistema.
c
¿Qué hace la función sigpending?
a) Modifica la acción asociada a una señal.
b) Consulta las señales pendientes.
c) Establece una alarma.
b
¿Cuál es la función de SIG_DFL en el contexto de sigaction?
a) Bloquear la señal.
b) Ignorar la señal.
c) Establecer la acción por defecto para la señal.
c
¿Qué función se utiliza para suspender la ejecución de un proceso hasta que una señal específica ocurra?
a) sigaction.
b) sigsuspend.
c) kill.
b
¿Cuál es el propósito de la función setitimer?
a) Enviar una señal a un proceso.
b) Establecer un temporizador que genere señales.
c) Capturar una señal con un manejador.
b
¿Qué hace la opción SA_SIGINFO en sigaction?
a) Ignora la señal.
b) Usa una función con argumentos adicionales para tratar la señal.
c) Bloquea la señal.
b
¿Qué función de la biblioteca stdlib puede usarse para enviar una señal a sí mismo?
a) raise.
b) abort.
c) exit.
a
¿Qué valor de pid se usa con kill para enviar una señal a todos los procesos del grupo cuyo PGID es -pid?
a) >0
b) 0
c) <-1
c
¿Cuál es la acción por defecto asociada a la señal SIGTERM?
a) Ignorar la señal.
b) Terminar el proceso.
c) Capturar la señal con un manejador.
b
¿Qué función debe usarse para definir un manejador de señal en sistemas POSIX?
a) signal.
b) sigaction.
c) raise.
b
¿Qué tipo de errores provoca la señal SIGBUS?
a) Violación de segmento de datos.
b) Error de acceso a memoria.
c) Instrucción ilegal.
b
¿Qué hace la opción SA_NODEFER en sigaction?
a) No bloquea la señal que se está tratando.
b) Restaura el manejador por defecto tras tratar la señal.
c) Reinicia ciertas llamadas al sistema interrumpidas.
a
¿Qué tipo de señal es SIGCHLD?
a) Señal de usuario.
b) Terminación del proceso hijo.
c) Interrupción.
b
¿Cuál es la acción por defecto para la señal SIGPIPE?
a) Terminar el proceso.
b) Ignorar la señal.
c) Capturar la señal con un manejador.
a
¿Qué indica el valor de retorno 0 en select?
a) Se produjo un error.
b) Algún descriptor está listo.
c) El tiempo máximo expiró sin que ningún descriptor esté listo.
c
¿Qué señal se envía con kill(getpid(), SIGABRT)?
a) SIGKILL.
b) SIGTERM.
c) SIGABRT.
c
¿Qué función se utiliza para manejar el evento de la muerte de un hijo?
a) wait.
b) waitpid.
c) Ambas.
c
¿Qué valor devuelve waitpid cuando no hay más hijos que esperar?
a) -1 y errno se establece en ECHILD.
b) 0.
c) 1.
a
¿Qué opción se usa con waitpid para no bloquear mientras espera?
a) WNOHANG.
b) WUNTRACED.
c) WCONTINUED.
a
¿Qué hace la función execl?
a) Crea un nuevo proceso.
b) Ejecuta un nuevo programa en el proceso actual.
c) Termina el proceso actual.
b
¿Qué valor de retorno tiene execl en caso de éxito?
a) 0.
b) 1.
c) No retorna en caso de éxito.
c
¿Qué hace la llamada al sistema fork?
a) Termina el proceso actual.
b) Crea un nuevo proceso duplicando el actual.
c) Ejecuta un nuevo programa en el proceso actual.
b
¿Cuál es la principal diferencia entre vfork y fork? (NO ESTA EN LOS APUNTES)
a) vfork no duplica el espacio de direcciones del padre.
b) fork no duplica el espacio de direcciones del padre.
c) vfork siempre falla si no hay suficiente memoria.
a
¿Qué hace atexit?
a) Registra una función para que se ejecute al terminar el proceso.
b) Termina el proceso inmediatamente.
c) Inicia un nuevo proceso.
a
¿Cuál de las siguientes funciones reemplaza la imagen del proceso actual?
a) fork.
b) execl.
c) wait.
b
¿Qué función se usa para cambiar el directorio actual del proceso?
a) chdir.
b) fchdir.
c) Ambas.
c
¿Qué señal se envía por defecto al usar el comando kill sin especificar una señal? (NO ESTA EN LOS APUNTES)
a) SIGKILL.
b) SIGTERM.
c) SIGINT.
b
¿Cuál es la señal utilizada para indicar un problema de memoria en el proceso?
a) SIGTERM.
b) SIGSEGV.
c) SIGUSR1.
b
¿Qué función se usa para convertir un descriptor de archivo a un descriptor de socket? (NO ESTA EN LOS APUNTES)
a) accept.
b) listen.
c) socketpair.
c
¿Qué opción de fcntl se usa para duplicar un descriptor de archivo?
a) F_DUPFD.
b) F_GETFL.
c) F_SETFL.
a
¿Qué hace la función dup2?
a) Duplica un descriptor de archivo y lo asigna a otro descriptor específico.
b) Cierra un descriptor de archivo.
c) Abre un nuevo archivo.
a
¿Qué nombre tiene el componente del núcleo que determina el orden de ejecución de los procesos en función de la clase de planificación y de la prioridad de los procesos?
a) Directorio
b) Planificador
c) Señal
b
¿Qué tipo de política de planificación es la siguiente? -> Política estándar de tiempo compartido con prioridad 0, que considera el valor de nice (entre -20 y 19, 0 por defecto) para repartir la CPU
a) SCHED_OTHER
b) SCHED_FIFO
c) SCHED_RR
a
¿Qué tipo de política de planificación es la siguiente? -> Política de tiempo real FIFO con prioridades entre 1 y 99
a) SCHED_OTHER
b) SCHED_FIFO
c) SCHED_RR
b
¿Qué tipo de política de planificación es la siguiente? -> Política de tiempo real FIFO con prioridades entre 1 y 99, pero los procesos con igual prioridad se ejecutan por turnos (round-robin) durante un cuanto de tiempo máximo
a) SCHED_OTHER
b) SCHED_FIFO
c) SCHED_RR
c
¿Qué valor en el PID hace referencia al proceso actual?
a) -1
b) 0
c) 1
b
El comando chrt nos ofrece acceso a varias funcionalidades del sistema, ¿Cúal de ellas nos permite establecer la política de planificación y/o prioridad?
a) int sched_setscheduler(pid_t pid, int policy, const struct sched_param *p)
b) int sched_setparam(pid_t pid, const struct sched_param *p)
c) int setpriority(int which, int who, int prio)
a
El comando chrt nos ofrece acceso a varias funcionalidades del sistema, ¿Cúal de ellas nos permite fijar una nueva prioridad, pero no cambiar la política?
a) int sched_setscheduler(pid_t pid, int policy, const struct sched_param *p)
b) int sched_setparam(pid_t pid, const struct sched_param *p)
c) int setpriority(int which, int who, int prio)
b
El comando chrt nos ofrece acceso a varias funcionalidades del sistema, ¿Cúal de ellas nos permite fijar la prioridad (nice) de un proceso?
a) int sched_setscheduler(pid_t pid, int policy, const struct sched_param *p)
b) int sched_setparam(pid_t pid, const struct sched_param *p)
c) int setpriority(int which, int who, int prio)
c
El comando chrt nos ofrece acceso a varias funcionalidades del sistema, ¿Cúal de ellas nos permite consultar tanto la política como la prioridad?
a) int sched_getscheduler(pid_t pid)
b) int sched_getparam(pid_t pid, struct sched_param *p)
c) int getpriority(int which, int who)
a
El comando chrt nos ofrece acceso a varias funcionalidades del sistema, ¿Cúal de ellas nos permite consultar los parámetros y la prioridad?
a) int sched_getscheduler(pid_t pid)
b) int sched_getparam(pid_t pid, struct sched_param *p)
c) int getpriority(int which, int who)
b
En la función int setpriority(int which, int who, int prio), que descripción corresponde con el parámetro which
a) es un PID, un PGID o un UID, respectivamente, 0 indica el proceso actual, el grupo de procesos del proceso actual o el UID real del proceso actual, respectivamente
b) es el nuevo valor de nice entre -20 y 19. Valores menores representan una mayor porción de CPU
c) puede ser PRIO_PROCESS, PRIO_PGRP o PRIO_USER
c
En la función int setpriority(int which, int who, int prio), que descripción corresponde con el parámetro who
a) es un PID, un PGID o un UID, respectivamente, 0 indica el proceso actual, el grupo de procesos del proceso actual o el UID real del proceso actual, respectivamente
b) es el nuevo valor de nice entre -20 y 19. Valores menores representan una mayor porción de CPU
c) puede ser PRIO_PROCESS, PRIO_PGRP o PRIO_USER
a
En la función int setpriority(int which, int who, int prio), que descripción corresponde con el parámetro prio
a) es un PID, un PGID o un UID, respectivamente, 0 indica el proceso actual, el grupo de procesos del proceso actual o el UID real del proceso actual, respectivamente
b) es el nuevo valor de nice entre -20 y 19. Valores menores representan una mayor porción de CPU
c) puede ser PRIO_PROCESS, PRIO_PGRP o PRIO_USER
b
¿Hereda los atributos de planificación la llamada fork()?
a) Si, si los heredan
b) No, no los heredan
c) No, los atributos de planificación son independientes de las llamadas fork()
a
¿Qué comando permite acceso a la funcionalidad de la prioridad? \
a) nice
b) renice
c) ambas opciones son válidas
c
¿Qué es el atributo PID?
a) número de prioridad de un proceso 
b) identificador único de un proceso
c) identificador del grupo de procesos al que pertenecen
b
¿Qué es el atributo PPID?
a) número de prioridad de un proceso 
b) identificador único de un proceso
c) identificador único del proceso que lo inició (PID padre)
c
¿Qué es el atributo PGID?
a) número de prioridad grupal de un proceso 
b) identificador único de un proceso
c) identificador del grupo de procesos al que pertenecen
c
Los grupos de procesos se pueden agrupar en sesiones, ¿Qué les identifica?
a) SID (Session ID)
b) PID (Process ID)
c) IID (Identity ID)
a
En la desconexión, todos los procesos asociados a la sesión de ese usuario reciben una señal, por lo que terminan y se eliminan ¿Qué señal es?
a) SIGSTOP
b) SIGQUIT
c) SIGHUP
c
¿Cúal es el carácter correcto para fin de cadena?
a) '\0'
b) '\n'
c) '\#'
a
¿Qué método obtiene variables de entorno?
a) char *getenv(const char *name )
b) int setenv(const char *name, const char *value, int overwrite)
c) int unsetenv(const char *name)
a
¿Qué método establece variables de entorno?
a) char *getenv(const char *name )
b) int setenv(const char *name, const char *value, int overwrite)
c) int unsetenv(const char *name)
b
¿Qué método elimina variables de entorno?
a) char *getenv(const char *name )
b) int setenv(const char *name, const char *value, int overwrite)
c) int unsetenv(const char *name)
c
¿Qué afirmación NO es correcta respecto a pid_t fork(void)?
a) Cada proceso dispone de un único identificador
b) El hijo hereda los cerrojos
c) El hijo recibe una copia de los descriptores de los ficheros abiertos por el padre
b
¿Qué afirmación NO es correcta respecto a pid_t fork(void)?
a) El hijo hereda las alarmas del padre
b) El hijo no hereda los cerrojos
c) El conjunto de señales pendientes del hijo es nulo
a
Un proceso puede finalizar por dos motivos, ¿Cuál es el incorrecto?
a) voluntariamente, llamando a exit (o return desde main())
b) al recibir una señal (hay múltiples causas)
c) de manera forzada a través del administrador de tareas
c
¿Cuál es la descripción correcta para WNOHANG de options en pid_t waitpid(pid_t pid, int *status, int options)? \
a) retorna sin esperar si no hay hijos que hayan terminado
b) retorna si el proceso ha sido detenido
c) retorna si un hijo detenido ha sido reanudado
a
¿Cuál es la descripción correcta para WUNTRACED de options en pid_t waitpid(pid_t pid, int *status, int options)? \
a) retorna sin esperar si no hay hijos que hayan terminado
b) retorna si el proceso ha sido detenido
c) retorna si un hijo detenido ha sido reanudado
b
¿Cuál es la descripción correcta para WCONTINUED de options en pid_t waitpid(pid_t pid, int *status, int options)?
a) retorna sin esperar si no hay hijos que hayan terminado
b) retorna si el proceso ha sido detenido
c) retorna si un hijo detenido ha sido reanudado
c
¿Cuál es la descripción correcta para WIFEXITED de status en pid_t waitpid(pid_t pid, int *status, int options)?
a) indica si el hijo terminó normalmente vía exit() y, en ese caso, WEXITSTATUS(s) devuelve el estado de salida
b) indica si el hijo terminó al recibir una señal y, en ese caso, WTERMSIG(s) devuelve el número de la señal recibida
c) ninguna es correcta
a
¿Cuál es la descripción correcta para WIFSIGNALED de status en pid_t waitpid(pid_t pid, int *status, int options)?
a) indica si el hijo terminó normalmente vía exit() y, en ese caso, WEXITSTATUS(s) devuelve el estado de salida
b) indica si el hijo terminó al recibir una señal y, en ese caso, WTERMSIG(s) devuelve el número de la señal recibida
c) ninguna es correcta
b
¿Qué función tiene el método int getrlimit(int resource, struct rlimit *rlim)?
a) Obtiene los límites del proceso
b) Obtiene las regulaciones limitantes del proceso
c) Obtiene los recursos limítrofes del proceso
a
¿Qué función tiene el método int setrlimit(int resource, const struct rlimit *rlim)?
a) Establece los límites del proceso
b) Establece las regulaciones limitantes del proceso
c) Establece los recursos limítrofes del proceso
a
¿Qué significa RLIMIT_NOFILE de resource dentro de los métodos getrlimit/setrlimit?
a) Max. número de procesos
b) Max. número de descriptores de archivo
c) Max. tamaño de archivo core (bytes)
b
¿Qué significa RLIMIT_CORE de resource dentro de los métodos getrlimit/setrlimit?
a) Max. número de procesos
b) Max. número de descriptores de archivo
c) Max. tamaño de archivo core (bytes)
c
¿Qué significa RLIMIT_NPROC de resource dentro de los métodos getrlimit/setrlimit?
a) Max. número de procesos
b) Max. número de descriptores de archivo
c) Max. tamaño de archivo core (bytes)
a
¿Qué significa RLIMIT_DATA de resource dentro de los métodos getrlimit/setrlimit?
a) Max. tamaño de archivo (bytes) 
b) Max. tamaño del heap (bytes)
c) Max. tamaño de pila (bytes)
b
¿Qué método sirve para obtener el uso de recursos?
a) char *getenv(const char *name )
b) int getrlimit(int resource, struct rlimit *rlim)
c) int getrusage(int who, struct rusage *usage)
c
¿Cuál es la señal que hace lo siguiente? -> desconexión de terminal (F, terminar proceso)
a) SIGHUP
b) SIGSTOP
c) SIGQUIT
a
¿Cuál es la señal que hace lo siguiente? -> Finalización. Se puede generar con Ctrl+\ (F y C, volcado de memoria)
a) SIGQUIT
b) SIGSTOP
c) SIGKILL 
a
¿Cuál es la señal que hace lo siguiente? -> Parar proceso. No se puede capturar, bloquear o ignorar (P, parar)
a) SIGTSTP
b) SIGSTOP
c) SIGQUIT 
b
¿Cuál es la señal que hace lo siguiente? -> Parar proceso. Se puede generar con Ctrl+Z (P)
a) SIGTSTP
b) SIGSTOP
c) SIGQUIT 
a
¿Cuál es la señal que hace lo siguiente? -> Instrucción ilegal (punteros a funciones mal gestionados) (F y C)
a) SIGTRAP
b) SIGSEGV
c) SIGILL 
c
¿Cuál es la señal que hace lo siguiente? -> Ejecución paso a paso, enviada después de cada instrucción (F y C)
a) SIGTRAP
b) SIGSEGV
c) SIGILL 
a
¿Cuál es la señal que hace lo siguiente? -> Terminación brusca. No se puede capturar, bloquear o ignorar (F)
a) SIGQUIT
b) SIGKILL 
c) SIGILL 
b
¿Cuál es la señal que hace lo siguiente? -> Error de acceso a memoria (alineación o dirección no válida) (F y C) \
a) SIGSEGV
b) SIGPIPE 
c) SIGBUS 
c
¿Cuál es la señal que hace lo siguiente? -> Violación de segmento de datos (F y C)
a) SIGSEGV
b) SIGPIPE 
c) SIGBUS 
a
¿Cuál es la señal que hace lo siguiente? -> Intento de escritura en un tubería sin lectores (F)
a) SIGSEGV
b) SIGPIPE 
c) SIGBUS 
b
¿Cuál es la señal que hace lo siguiente? -> Despertador, contador a 0 (F)
a) SIGALRM
b) SIGPIPE 
c) SIGTERM 
a
¿Cuál es la señal que hace lo siguiente? -> Terminar proceso (F)
a) SIGQUIT
b) SIGKILL  
c) SIGTERM 
c
¿Cuál es la señal que hace lo siguiente? -> Señales de usuario (F)
a) SIGUSR1
b) SIGUSR2  
c) SIGUSR1, SIGUSR2 (Ambas) 
c
¿Cuál es la señal que hace lo siguiente? -> Terminación del proceso hijo (I, ignorar)
a) SIGCHLD
b) SIGKILL  
c) SIGTERM 
a
¿Cuál es la señal que hace lo siguiente? -> Recepción de datos urgentes en socket (I)
a) SIGHUP
b) SIGURG  
c) SIGTERM 
b
¿Qué llamada NO es equivalente a int kill(pid_t pid, int signal), que envía una señal a un proceso?
a) int raise(int signal)
b) int abort(void)
c) int destroy(pid_t pid, int signal)
c
¿Cuál es la afirmación correcta sobre conjuntos de señales?
a) La gestión de señales se puede realizar conjuntamente por su nombre o identificador o individualmente usando conjuntos de señales sigset_t donde cada bit representa una señal
b) La gestión de señales se puede realizar individualmente por su nombre o identificador o conjuntamente usando conjuntos de señales sigset_t donde cada bit representa una señal
c) La gestión de señales se puede realizar conjuntamente por su nombre o identificador o individualmente usando conjuntos de señales sigget_t donde cada bit representa una señal
b
En la función int sigprocmask(int how, const sigset_t *set, sigset_t *oset), ¿Cúal es el comportamiento de how correcto para SIG_BLOCK ?
a) Reemplaza el conjunto de señales actuales por set
b) Elimina el conjunto set del conjunto de señales bloqueadas (puede desbloquearse una señal que no estuviera bloqueada)
c) Añade el conjunto set al conjunto de señales actualmente bloqueadas (“OR”)
c
En la función int sigprocmask(int how, const sigset_t *set, sigset_t *oset), ¿Cúal es el comportamiento de how correcto para SIG_UNBLOCK ?
a) Reemplaza el conjunto de señales actuales por set
b) Elimina el conjunto set del conjunto de señales bloqueadas (puede desbloquearse una señal que no estuviera bloqueada)
c) Añade el conjunto set al conjunto de señales actualmente bloqueadas (“OR”)
b
En la función int sigprocmask(int how, const sigset_t *set, sigset_t *oset), ¿Cúal es el comportamiento de how correcto para SIG_SETMASK ?
a) Reemplaza el conjunto de señales actuales por set
b) Elimina el conjunto set del conjunto de señales bloqueadas (puede desbloquearse una señal que no estuviera bloqueada)
c) Añade el conjunto set al conjunto de señales actualmente bloqueadas (“OR”)
a
¿Qué método sirve para consultar y establecer las señales bloqueadas?
a) int sigprocmask(int how, const sigset_t *set, sigset_t *oset)
b) int sigaction(int signal, const struct sigaction *act, struct sigaction *oldact)
c) int sigpending(const sigset_t *set)
a
¿Qué método sirve para comprobar señales pendientes?
a) int sigprocmask(int how, const sigset_t *set, sigset_t *oset)
b) int sigaction(int signal, const struct sigaction *act, struct sigaction *oldact)
c) int sigpending(const sigset_t *set)
c
¿Qué método sirve para obtener y establecer la acción asociada a una señal?
a) int sigprocmask(int how, const sigset_t *set, sigset_t *oset)
b) int sigaction(int signal, const struct sigaction *act, struct sigaction *oldact)
c) int sigpending(const sigset_t *set)
b
¿Cuál es la acción por defecto en la recepción de una señal?
a) no existe una acción por defecto en la recepción de una señal, simplemente se activa la señal
b) la habilitación de la señal, o bien, activar la señal recibida 
c) la finalización del proceso, o bien, simplemente ignorar la señal
c
En el struct sigaction {void (*sa_handler) (int);sigset_t sa_mask;int sa_flags;...} cual es la descripción correcta para el campo -> sa_handler 
a) modifica el comportamiento del proceso de gestión de la señal: SA_RESTART, SA_RESETHAND y SA_SIGINFO 
b) es el nuevo manejador para la señal. Su valor puede ser: SIG_DFL: Para el manejador por defecto. SIG_IGN: Para no atender la señal. Un puntero a una función
c) es el conjunto de señales que serán bloqueadas durante el tratamiento de la señal. Además, se bloquea la señal en cuestión (si no se indica el flag SA_NODEFER)
b
En el struct sigaction {void (*sa_handler) (int);sigset_t sa_mask;int sa_flags;...} cual es la descripción correcta para el campo -> sa_mask  
a) modifica el comportamiento del proceso de gestión de la señal: SA_RESTART, SA_RESETHAND y SA_SIGINFO 
b) es el nuevo manejador para la señal. Su valor puede ser: SIG_DFL: Para el manejador por defecto. SIG_IGN: Para no atender la señal. Un puntero a una función
c) es el conjunto de señales que serán bloqueadas durante el tratamiento de la señal. Además, se bloquea la señal en cuestión (si no se indica el flag SA_NODEFER)
c
En el struct sigaction {void (*sa_handler) (int);sigset_t sa_mask;int sa_flags;...} cual es la descripción correcta para el campo -> sa_flags   
a) modifica el comportamiento del proceso de gestión de la señal: SA_RESTART, SA_RESETHAND y SA_SIGINFO 
b) es el nuevo manejador para la señal. Su valor puede ser: SIG_DFL: Para el manejador por defecto. SIG_IGN: Para no atender la señal. Un puntero a una función
c) es el conjunto de señales que serán bloqueadas durante el tratamiento de la señal. Además, se bloquea la señal en cuestión (si no se indica el flag SA_NODEFER)
a
Dentro del campo sa_flags del struct sigaction, ¿Cuál corresponde con -> reinicia llamadas al sistema interrumpidas (en caso contrario terminan con EINTR) para compatibilidad con BSD?
a) SA_RESTART 
b) SA_SIGINFO 
c) SA_RESETHAND 
a
Dentro del campo sa_flags del struct sigaction, ¿Cuál corresponde con -> restaura el manejador por defecto tras tratar la señal?
a) SA_RESTART 
b) SA_SIGINFO 
c) SA_RESETHAND 
c
Dentro del campo sa_flags del struct sigaction, ¿Cuál corresponde con -> usa otro manejador (sa_sigaction) de la función con argumentos adicionales?
a) SA_RESTART 
b) SA_SIGINFO 
c) SA_RESETHAND 
b
¿Qué ocurre cuando un manejador termina?
a) No ocurre nada, se continúa con la siguiente ejecución
b) Se restaura la ejecución en el punto donde se produjo la señal
c) Envía una señal de finalización del menejador y continúa en la siguiente ejecución
b
¿Cuál NO es una precaución a tomar en el manejador?
a) Declarar las variables globales como no volatile
b) No usar funciones no reentrantes, como malloc, free o funciones de la librería stdio
c) Guardar y restaurar el valor de errno si llama a alguna función que pueda modificarlo
a
¿Cuál NO es una precaución a tomar en el manejador?
a) Declarar las variables globales como volatile
b) Usar funciones no reentrantes, como malloc, free o funciones de la librería stdio
c) Guardar y restaurar el valor de errno si llama a alguna función que pueda modificarlo
b
¿Cuál NO es una precaución a tomar en el manejador?
a) Declarar las variables globales como volatile
b) No usar funciones no reentrantes, como malloc, free o funciones de la librería stdio
c) Eliminar y restaurar el valor de errno si llama a alguna función que pueda modificarlo
c
¿Qué hace el método de int sigsuspend(const sigset_t *set)?
a) Suspender la ejecución del proceso y ejecutar la siguiente señal
b) Esperar la ocurrencia de una determinada señal, suspendiendo la ejecución del proceso
c) Ninguna opcion es correcta
b
¿Cuál de las siguientes afirmaciones no es correcta respecto a int sigsuspend(const sigset_t *set)?
a) La máscara de señales bloqueadas se sustituye temporalmente por el conjunto get, el proceso se suspende hasta que una señal que no esté en la máscara se produzca
b) Cuando se recibe la señal se ejecuta el manejador asociado a la señal y continúa la ejecución del proceso, restaurando la máscara original
c) Siempre devuelve -1 y, normalmente, establece errno a EINTR
a
¿Cuál de las siguientes afirmaciones no es correcta respecto a int sigsuspend(const sigset_t *set)?
a) La máscara de señales bloqueadas se sustituye temporalmente por el conjunto set, el proceso se suspende hasta que una señal que no esté en la máscara se produzca
b) Cuando se recibe la señal se ejecuta el manejador asociado a la señal y se detiene la ejecución del proceso, restaurando la máscara original
c) Siempre devuelve -1 y, normalmente, establece errno a EINTR
b
¿Cuál de las siguientes afirmaciones es correcta respecto a unsigned int alarm(unsigned int secs)?
a) No se heredan con fork(2), pero sí se mantienen tras execve(2)
b) Si se heredan con fork(2) y no se se mantienen tras execve(2)
c) No se heredan con fork(2) y no se mantienen tras execve(2)
a
¿Cuál de las siguientes afirmaciones no es correcta respecto a unsigned int alarm(unsigned int secs)?
a) Se programa el temporizador ITIMER_REAL para generar una señal SIGALRM en secs segundos (si es cero, no se planifica ninguna nueva alarma)
b) Devuelve el valor de segundos restantes para que se produzca el final de la cuenta (0 si no hay ninguna fijada)
c) Se pueden mezclar con sleep(3) o cualquier otra función que use el mismo temporizador, como setitimer(2)
c
En una tubería sin nombres, ¿Qué ocurre si está vacía?
a) write(2) se bloqueará hasta que se lean suficientes datos para que se pueda completar la escritura
b) se bloqueará hasta que haya datos disponibles
c) el extremo de lectura se abre con el flag O_RDONLY y el de escritura, con O_WRONLY
b
En una tubería sin nombres, ¿Qué ocurre si está llena?
a) write(2) se bloqueará hasta que se lean suficientes datos para que se pueda completar la escritura
b) se bloqueará hasta que haya datos disponibles
c) el extremo de lectura se abre con el flag O_RDONLY y el de escritura, con O_WRONLY
a
En una tubería sin nombres, ¿Qué ocurre si todos los descriptores de escritura se han cerrado?
a) write(2) enviará la señal SIGPIPE al proceso y, si se ignora la señal, fallará con EPIPE
b) el núcleo realiza la sincronización y almacena los datos internamente, sin escribirlos en el sistema de ficheros
c) read(2) devolverá cero, indicando el fin de fichero
c
En una tubería sin nombres, ¿Qué ocurre si todos los descriptores de lectura se han cerrado?
a) write(2) enviará la señal SIGPIPE al proceso y, si se ignora la señal, fallará con EPIPE
b) el núcleo realiza la sincronización y almacena los datos internamente, sin escribirlos en el sistema de ficheros
c) read(2) devolverá cero, indicando el fin de fichero
a
En una tubería con nombres, con que flag se abre el extremo de lectura?
a) O_WRONLY y el de escritura, con O_RDONLY
b) O_RDONLY y el de escritura, con O_WRONLY
c) Ninguna de las anteriores
b
¿En qué consiste en las tuberías la multiplexación de E/S síncrona?
a) Consiste en implementar múltiples descriptores de fichero, esperando hasta que uno o varios estén listos para realizar una operación de E/S de forma síncrona
b) Consiste en implementar múltiples descriptores de fichero, esperando hasta que uno o varios estén listos para realizar una operación de E/S de forma asíncrona
c) Consiste en monitorizar múltiples descriptores de fichero, esperando hasta que uno o varios estén listos para realizar una operación de E/S de forma síncrona
c